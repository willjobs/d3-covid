<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <link rel="icon" href="data:;base64,=">
        <title>Viz 1</title>
        <script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
        <style type="text/css">
            body {
                font-family: sans-serif;
            }
            .spinner {
                border: 16px solid #f3f3f3; /* Light grey */
                border-top: 16px solid #3498db; /* Blue */
                border-radius: 50%;
                width: 120px;
                height: 120px;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            .hover-bar {
                stroke-width: 1px;
                stroke: white;
                stroke-opacity: 0.5;
                -webkit-filter: drop-shadow( 2px 2px 2px rgba(0, 0, 0, .6));
                filter: drop-shadow( 2px 2px 2px rgba(0, 0, 0, .6));
            }

            .line {
                fill: none;
                stroke: steelblue;
                stroke-width: 2px;
            }

            .grid line {
                stroke: lightgrey;
                stroke-opacity: 0.7;
                shape-rendering: crispEdges;
            }

            .grid path {
                stroke-width: 0;
            }

            .tooltip {
                position: absolute;
                display: none;
                min-width: 80px;
                height: auto;
                background: none repeat scroll 0 0 #ffffff;
                border: 1px solid #6F257F;
                padding: 14px;
                text-align: center;
                border-radius: 10px;
            }
        </style>
    </head>
    <body>
        <div class="spinner"></div>

        <!-- to be populated using unique countries in dataset -->
        <select name="viz1-countries" id="viz1-countries" multiple></select>

        <div class="viz1"></div>

        <script type="text/javascript">
            // NOTE: always used classed("myclass", true) and not classed("myclass"), because the latter
            // will overwrite any classes that already exist there, which may not be what you want.
            const FONT_SIZES = {
                tick: 12,
                axisTitle: 14,
                title: 16
            }

            // color scale is here: https://github.com/d3/d3-scale-chromatic#schemeTableau10
            const continentColors = d3.scaleOrdinal(d3.schemeTableau10)
                                        .domain(["Africa", "Asia", "Europe", "North America", "Oceania", "South America"]);

            var viz1 = {};  // empty object which will contain all stuff necessary for drawing/redrawing viz1

            var parseDate = d3.timeParse("%Y-%m-%d");  // for converting strings to dates ("2020-03-31", for example)
            var formatDate = d3.timeFormat("%b %e");  // for converting dates to strings

            var covidData;
            var dataDict;
            var viz1SelectedCountries = [];

            // TODO: delete this when ready for attribute dropdown and date slider
            var attribute = "new_cases";
            var the_date = parseDate("2020-07-01");

            function dictRowParser(d) {
                return {
                    variable_name :  d.variable_name,  // name of attribute in CSV
                    data_type :      d.data_type,  // string, date, numeric, or ordinal
                    display_name :   d.display_name,  // pretty name of variable, for dropdowns, titles, etc.
                    sort_order :     parseInt(d.sort_order),  // when showing in dropdown menus, sort in this order
                    category :       d.category,   // when grouping variables (e.g., in a summary table, these are the groupings)
                    numeric_column : d.numeric_column  // for ordinal columns, e.g., c1_school_closing, there is a corresponding "numeric" column
                };
            }

            function dataRowParser(d) {
                return {
                    countryname :                                  d.countryname, 
                    date :                                         parseDate(d.date), 
                    c1_school_closing_numeric :                    parseFloat(d.c1_school_closing_numeric), 
                    c1_school_closing :                            d.c1_school_closing, 
                    c2_workplace_closing_numeric :                 parseFloat(d.c2_workplace_closing_numeric), 
                    c2_workplace_closing :                         d.c2_workplace_closing, 
                    c3_cancel_public_events_numeric :              parseFloat(d.c3_cancel_public_events_numeric), 
                    c3_cancel_public_events :                      d.c3_cancel_public_events, 
                    c4_restrictions_on_gatherings_numeric :        parseFloat(d.c4_restrictions_on_gatherings_numeric), 
                    c4_restrictions_on_gatherings :                d.c4_restrictions_on_gatherings, 
                    c5_close_public_transport_numeric :            parseFloat(d.c5_close_public_transport_numeric), 
                    c5_close_public_transport :                    d.c5_close_public_transport, 
                    c6_stay_at_home_requirements_numeric :         parseFloat(d.c6_stay_at_home_requirements_numeric), 
                    c6_stay_at_home_requirements :                 d.c6_stay_at_home_requirements, 
                    c7_restrictions_on_internal_movement_numeric : parseFloat(d.c7_restrictions_on_internal_movement_numeric), 
                    c7_restrictions_on_internal_movement :         d.c7_restrictions_on_internal_movement, 
                    c8_international_travel_controls :             d.c8_international_travel_controls, 
                    e1_income_support_numeric :                    parseFloat(d.e1_income_support_numeric), 
                    e1_income_support :                            d.e1_income_support, 
                    e2_debt_contract_relief :                      d.e2_debt_contract_relief, 
                    h1_public_information_campaigns_numeric :      parseFloat(d.h1_public_information_campaigns_numeric), 
                    h1_public_information_campaigns :              d.h1_public_information_campaigns, 
                    h2_testing_policy :                            d.h2_testing_policy, 
                    h3_contact_tracing :                           d.h3_contact_tracing, 
                    h6_facial_coverings_numeric :                  parseFloat(d.h6_facial_coverings_numeric), 
                    h6_facial_coverings :                          d.h6_facial_coverings, 
                    h7_vaccination_policy_numeric :                parseFloat(d.h7_vaccination_policy_numeric), 
                    h7_vaccination_policy :                        d.h7_vaccination_policy, 
                    h8_combined_numeric :                          parseFloat(d.h8_combined_numeric), 
                    h8_combined :                                  d.h8_combined, 
                    stringency_index :                             parseFloat(d.stringency_index), 
                    government_response_index :                    parseFloat(d.government_response_index), 
                    containment_health_index :                     parseFloat(d.containment_health_index), 
                    economic_support_index :                       parseFloat(d.economic_support_index), 
                    continent :                                    d.continent, 
                    total_cases :                                  parseFloat(d.total_cases), 
                    new_cases :                                    parseFloat(d.new_cases), 
                    new_cases_smoothed :                           parseFloat(d.new_cases_smoothed), 
                    total_deaths :                                 parseFloat(d.total_deaths), 
                    new_deaths :                                   parseFloat(d.new_deaths), 
                    new_deaths_smoothed :                          parseFloat(d.new_deaths_smoothed), 
                    total_cases_per_million :                      parseFloat(d.total_cases_per_million), 
                    new_cases_per_million :                        parseFloat(d.new_cases_per_million), 
                    new_cases_smoothed_per_million :               parseFloat(d.new_cases_smoothed_per_million), 
                    total_deaths_per_million :                     parseFloat(d.total_deaths_per_million), 
                    new_deaths_per_million :                       parseFloat(d.new_deaths_per_million), 
                    new_deaths_smoothed_per_million :              parseFloat(d.new_deaths_smoothed_per_million), 
                    reproduction_rate :                            parseFloat(d.reproduction_rate), 
                    icu_patients :                                 parseFloat(d.icu_patients), 
                    icu_patients_per_million :                     parseFloat(d.icu_patients_per_million), 
                    hosp_patients :                                parseFloat(d.hosp_patients), 
                    hosp_patients_per_million :                    parseFloat(d.hosp_patients_per_million), 
                    weekly_icu_admissions :                        parseFloat(d.weekly_icu_admissions), 
                    weekly_icu_admissions_per_million :            parseFloat(d.weekly_icu_admissions_per_million), 
                    weekly_hosp_admissions :                       parseFloat(d.weekly_hosp_admissions), 
                    weekly_hosp_admissions_per_million :           parseFloat(d.weekly_hosp_admissions_per_million), 
                    new_tests :                                    parseFloat(d.new_tests), 
                    total_tests :                                  parseFloat(d.total_tests), 
                    total_tests_per_thousand :                     parseFloat(d.total_tests_per_thousand), 
                    new_tests_per_thousand :                       parseFloat(d.new_tests_per_thousand), 
                    new_tests_smoothed :                           parseFloat(d.new_tests_smoothed), 
                    new_tests_smoothed_per_thousand :              parseFloat(d.new_tests_smoothed_per_thousand), 
                    positive_rate :                                parseFloat(d.positive_rate), 
                    tests_per_case :                               parseFloat(d.tests_per_case), 
                    tests_units :                                  d.tests_units, 
                    total_vaccinations :                           parseFloat(d.total_vaccinations), 
                    people_vaccinated :                            parseFloat(d.people_vaccinated), 
                    people_fully_vaccinated :                      parseFloat(d.people_fully_vaccinated), 
                    new_vaccinations :                             parseFloat(d.new_vaccinations), 
                    new_vaccinations_smoothed :                    parseFloat(d.new_vaccinations_smoothed), 
                    total_vaccinations_per_hundred :               parseFloat(d.total_vaccinations_per_hundred), 
                    people_vaccinated_per_hundred :                parseFloat(d.people_vaccinated_per_hundred), 
                    people_fully_vaccinated_per_hundred :          parseFloat(d.people_fully_vaccinated_per_hundred), 
                    new_vaccinations_smoothed_per_million :        parseFloat(d.new_vaccinations_smoothed_per_million), 
                    population :                                   parseFloat(d.population), 
                    population_density :                           parseFloat(d.population_density), 
                    median_age :                                   parseFloat(d.median_age), 
                    aged_65_older :                                parseFloat(d.aged_65_older), 
                    aged_70_older :                                parseFloat(d.aged_70_older), 
                    gdp_per_capita :                               parseFloat(d.gdp_per_capita), 
                    extreme_poverty :                              parseFloat(d.extreme_poverty), 
                    cardiovasc_death_rate :                        parseFloat(d.cardiovasc_death_rate), 
                    diabetes_prevalence :                          parseFloat(d.diabetes_prevalence), 
                    female_smokers :                               parseFloat(d.female_smokers), 
                    male_smokers :                                 parseFloat(d.male_smokers), 
                    handwashing_facilities :                       parseFloat(d.handwashing_facilities), 
                    hospital_beds_per_thousand :                   parseFloat(d.hospital_beds_per_thousand), 
                    life_expectancy :                              parseFloat(d.life_expectancy), 
                    human_development_index :                      parseFloat(d.human_development_index), 
                    e3_fiscal_measures :                           parseFloat(d.e3_fiscal_measures), 
                    e4_international_support :                     parseFloat(d.e4_international_support), 
                    h4_emergency_investment_in_healthcare :        parseFloat(d.h4_emergency_investment_in_healthcare), 
                    h5_investment_in_vaccines :                    parseFloat(d.h5_investment_in_vaccines), 
                    new_vaccinations_per_hundred :                 parseFloat(d.new_vaccinations_per_hundred)
                };
            }


            // function used to wrap long names on y-axis
            // see: https://bl.ocks.org/mbostock/7555321
            function wrap(label_, height) {
                label_.each(function(d) {
                    let label = d3.select(this);
                    let words = label.text().split(/\s+/).reverse();

                    if(words.length > 1) {
                        let word;
                        let lineNumber = 0;
                        let lineHeight = FONT_SIZES.tick;  // px

                        let y = label.attr("y");
                        let dy = parseFloat(label.attr("dy"));
                        let shift_text_y = 0;
                        
                        // for centering (vertically) countries with multiple words (e.g., Democratic Republic of Congo)
                        if(words.length > 2) {
                            // no magic to this formula; just what I discovered works best
                            shift_text_y = Math.floor(-2.5 - (FONT_SIZES.tick - 1)/2 * (words.length - 2));
                        }

                        label.text(null)
                            .attr("transform", "translate(0, " + shift_text_y + ")");

                        subtext = label.append("tspan")
                                    .attr("transform", "translate(0, -10)");

                        while (word = words.pop()) {
                            subtext.append("tspan")
                                .attr("x", -10)
                                .attr("y", Math.floor((lineNumber * lineHeight)) + "px").text(word)
                                .attr("dy", dy);
                            lineNumber++;
                        }
                    }
                });
            };


            function makeViz1() {
                viz1.margin = {top: 20, right: 20, bottom: 40, left: 100};

                viz1.dims = {height: 400, width: d3.max([600,  // no smaller than 600px wide
                                                    d3.min([900, // no larger than 900px wide
                                                            Math.floor(window.innerWidth / 2)])])};
                viz1.dims["innerHeight"] = viz1.dims.height - viz1.margin.top - viz1.margin.bottom
                viz1.dims["innerWidth"] = viz1.dims.width - viz1.margin.left - viz1.margin.right

                viz1.svg = d3.select("div.viz1")
                                .append("svg")
                                    .attr("width", viz1.dims.width)
                                    .attr("height", viz1.dims.height)
                                    .classed("viz1", true)
                                .append("g")
                                    .attr("transform", "translate(" + viz1.margin.left + "," + viz1.margin.top + ")");

                viz1.yScale = d3.scaleBand()
                                .rangeRound([0, viz1.dims.innerHeight - 10])
                                .paddingInner(0.1);

                viz1.xScale = d3.scaleLinear()
                                .rangeRound([0, viz1.dims.innerWidth]); // rangeRound ensures all pixel values are non-fractional

                // make y-axis
                viz1.svg.append("g")
                    .classed("viz1 y axis", true);

                viz1.yAxis = d3.axisLeft(viz1.yScale);
                
                // make x-axis
                viz1.svg.append("g")
                    .classed("viz1 x axis", true)
                    .attr("transform", "translate(0," + viz1.dims.innerHeight + ")");

                viz1.xAxis = d3.axisBottom(viz1.xScale);

                // x-axis title
                viz1.svg.append("text")
                    .classed("viz1 x axis-title", true)
                    .attr("transform",
                            "translate(" + (viz1.dims.innerWidth/2) + " ," + 
                                        (viz1.dims.innerHeight + viz1.margin.top + 20) + ")")
                    .style("text-anchor", "middle")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", FONT_SIZES.axisTitle)
                    .text(attribute);
                
                // x-axis gridlines
                // see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
                viz1.svg.append("g")
                    .classed("viz1 x grid", true)
                    .attr("transform", "translate(0," + viz1.dims.innerHeight + ")");
                
                viz1.xAxisTicks = d3.axisBottom(viz1.xScale)
                                    .ticks(5)
                                    .tickSize(-viz1.dims.innerHeight)
                                    .tickFormat("");

                viz1.tooltip = d3.select("body")
                                .append("div")
                                .classed("viz1 tooltip", true);

                // set all ticks' fonts. These aren't styles/CSS, these are attributes
                d3.selectAll(".viz1.axis")
                    .attr("font-size", FONT_SIZES.tick)
                    .attr("font-family", "sans-serif");

            }
            

            function redrawViz1() {
                let viz1Data = covidData.filter(d => viz1SelectedCountries.includes(d.countryname) && 
                                                     d.date.getTime() == the_date.getTime());

                // TODO: handle missing values (convert to 0) (use javascript .isNaN)
                // test cases:
                //  Liechtenstein: longest single word country
                //  Peru: shortest single word country
                //  United States: 2-word country
                //  Bosnia and Herzegovina: 3-word country
                //  Democratic Republic of Congo: longest length, and 4-word country

                // in case we removed all the data, don't show any axes or gridlines
                let axis_visibility = viz1Data.length == 0 ? "display:none" : "";
                d3.selectAll(".x").attr("style", axis_visibility);
                d3.selectAll(".y").attr("style", axis_visibility);
                d3.selectAll(".grid").attr("style", axis_visibility);

                /******
                 * update y-axis
                ******/
                //** Doing it this way so that we can maintain the order in which the user selected countries
                // Uncomment the below if you want to do it in the order of the dataset, not the user's selection:
                //      viz1.yScale.domain(viz1Data.map(d => d.countryname));
                viz1.yScale.domain(viz1SelectedCountries);

                d3.select(".viz1.y.axis")
                    .transition()
                    .duration(500)
                    .call(viz1.yAxis)
                    .on("end", function() {x = d3.selectAll(".viz1.y.axis .tick text")
                                                    .filter(d => d.includes(" "))
                                                    .call(wrap, viz1.yScale.bandwidth());

                                          });

                // remove y-axis ticks and vertical black line
                d3.selectAll(".viz1.y.axis .tick line").remove();
                d3.selectAll(".viz1.y.axis path").remove();

                /******
                 * update x-axis
                ******/
                viz1.xScale.domain([0, d3.max(viz1Data, d => d[attribute])]);

                d3.select(".viz1.x.axis")
                    .transition()
                    .duration(300)
                    .call(viz1.xAxis);
                
                // update x-axis title in case the attribute changed
                d3.select("text.viz1.x.axis-title")
                    .text(attribute);

                // add the X gridlines
                // see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
                d3.select(".viz1.grid")
                    .call(viz1.xAxisTicks);

                // Create the bars: there will be one with the actual data, and one that is invisible
                // which extends the length of the chart and activates the hover effect
                let bars = viz1.svg.selectAll("rect")
                            .data(viz1Data, d => d.countryname);

                bars.exit()
                    .transition()
                    .duration(300)
                    .style("fill-opacity", 0)
                    .remove();

                bars.enter()
                    .append("rect")
                        .attr("fill", d => continentColors(d.continent))
                        .classed("viz1 bar", true)
                        .attr("id", function(d,i) {return "viz1-bar" + i})
                        .merge(bars)
                            .on("mouseover", function() {
                                d3.select(this).classed("hover-bar", true);
                            }).on("mousemove", function(event, d) {
                                viz1.tooltip
                                    .style("left", event.pageX - 50 + "px")
                                    .style("top", event.pageY - 70 + "px")
                                    .style("display", "inline-block")
                                    .html((d.countryname) + "<br><b>" + attribute + "</b>: " + d[attribute]);
                            }).on("mouseout", function() {
                                d3.select(this).classed("hover-bar", false);
                                viz1.tooltip.style("display", "none");
                            })
                            .transition()
                            .duration(500)
                            .attr("y", d => viz1.yScale(d.countryname))
                            .attr("height", viz1.yScale.bandwidth())
                            .attr("width", d => viz1.xScale(d[attribute]));

                // Add a transparent bar on top that extends the width of the chart so we can activate
                //     the hover effect at any point along axis in the case of short bars.
                // Also include a tooltip! (reference: https://bl.ocks.org/alandunning/274bf248fd0f362d64674920e85c1eb7)
            }

            // load the data and kick things off
            Promise.all([
                d3.csv("../data/data_dictionary.csv", dictRowParser),
                d3.csv("../data/covid_data.csv", dataRowParser),
            ]).then(function(files) {
                dataDict = files[0];
                covidData = files[1];
                d3.selectAll(".spinner").remove();
                console.log("Imported all data!");

                // get unique countries and put those into the dropdown
                Array.from(new Set(covidData.map(d => d.countryname)))
                    .sort()  // put country names in order in dropdown menu
                    .forEach(function(country) {
                        d3.select("select#viz1-countries")
                            .append('option')
                            .attr("value", country)
                            .text(country);
                    });

                // populate the select list with countries

                makeViz1();
                redrawViz1();

                d3.select("#viz1-countries")
                    .on("change", function() {
                        let countries = [];

                        selected = d3.select(this)
                            .selectAll("option:checked") 
                            .each(function() { countries.push(this.value) }); // for each select country, get its value (name)

                        // want to maintain ordering of original selection
                        viz1SelectedCountries = viz1SelectedCountries.filter(d => countries.includes(d));
                        added = countries.filter(d => !viz1SelectedCountries.includes(d));
                        viz1SelectedCountries = viz1SelectedCountries.concat(added)

                        console.log(viz1SelectedCountries);

                        redrawViz1();
                    });

            }).catch(function(err) {
                d3.selectAll(".spinner").remove();
                console.error('Error: ' + err);
            })
        </script>
    </body>
</html>
