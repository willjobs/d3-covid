<!DOCTYPE html>
<html lang="en">
	<head>

		<!DOCTYPE html>
		<meta charset="utf-8">

		<title>Project: Second graph</title>

		<!-- Load d3.js -->
		<script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
		
		<style type="text/css">
			

			body{
				font-family: Arial;
			}
			h1{
				color: #0099FF;
			}
			p{
				color: #000000;
			}
			tr{
				background-color: #FF8448;

			}
			td{
				background-color: #0099FF;

			}
			table{
				color: #FFFFFF;
			}
			

		</style>

		<!-- Create a div where the graph will take place -->
		<div id="my_dataviz"></div>

		<!-- Color Scale -->
		<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

	</head>
	<body>
		<div class="spinner"></div>

        
        <label for="viz2-categories">Category: </label><select name="viz2-categories" id="viz2-categories"></select>
        <br><br>

		<label for="viz2-attributes">Attribute: </label><select name="viz2-attributes" id="viz2-attributes"></select>
        <br><br>

		<label for="viz2-countries">Countries: </label><select name="viz2-countries" id="viz2-countries" multiple></select>
        <br><br>


		<div class="viz2"></div>

		<script type="text/javascript">

		/******
		 * TO DO:
		 * 
		 * 1) change x axis with rotation --> see Will's code
		 * 2) append lines/paths depending of all country selected
		 * 3) create a double dropdown with categories and attributes
		 * 4) create the table for all atribute of the category that is selected
		 * 5) Add a country that is selected when opening the app
		 * 6) ADD hover effect
		 * 7) add subtilte with countries that are selected
		 * 8) add colorscale in table
		 * 
		 * Questions:
		 * 
		 * 1) how to use the variables of the dataset for the lines
		******/


		// NOTE: always used classed("myclass", true) and not classed("myclass"), because the latter
		// will overwrite any classes that already exist there, which may not be what you want.
		const FONT_SIZES = {
			tick: 12,
			axisTitle: 14,
			title: 16
		}

		// color scale is here: https://github.com/d3/d3-scale-chromatic#schemeTableau10
        const continentColors = d3.scaleOrdinal(d3.schemeTableau10)
                                    .domain(["Africa", "Asia", "Europe", "North America", "Oceania", "South America"]);


		// TO CHANGE to viz2 !!!!!!!
		var viz2 = {};  

		var parseDate = d3.timeParse("%Y-%m-%d");  // for converting strings to dates ("2020-03-31", for example)

		var covidData;
		var dataDict;
		var viz2SelectedCountries = [];
		var category;
		var viz2SelectedCategory = [];
		var attribute;
		var shortenTransitions = 0;

		// WHY????? what is it 
		// delete when ready for date slider
		var theDate;



		function dictRowParser(d) {
						return {
							variable_name :  d.variable_name,  // name of attribute in CSV
							data_type :      d.data_type,  // string, date, numeric, or ordinal
							display_name :   d.display_name,  // pretty name of variable, for dropdowns, titles, etc.
							sort_order :     parseInt(d.sort_order),  // when showing in dropdown menus, sort in this order
							category :       d.category,   // when grouping variables (e.g., in a summary table, these are the groupings)
							numeric_column : d.numeric_column  // for ordinal columns, e.g., c1_school_closing, there is a corresponding "numeric" column
						};
					}

		function dataRowParser(d) {
			return {
				countryname :                                  d.countryname,
				date :                                         parseDate(d.date),
				continent :                                    d.continent,
				new_cases :                                    parseFloat(d.new_cases),
				new_cases_per_million :                        parseFloat(d.new_cases_per_million),
				total_cases :                                  parseFloat(d.total_cases),
				total_cases_per_million :                      parseFloat(d.total_cases_per_million),
				new_deaths :                                   parseFloat(d.new_deaths),
				new_deaths_per_million :                       parseFloat(d.new_deaths_per_million),
				total_deaths :                                 parseFloat(d.total_deaths),
				total_deaths_per_million :                     parseFloat(d.total_deaths_per_million),
				new_tests :                                    parseFloat(d.new_tests),
				new_tests_per_thousand :                       parseFloat(d.new_tests_per_thousand),
				total_tests :                                  parseFloat(d.total_tests),
				total_tests_per_thousand :                     parseFloat(d.total_tests_per_thousand),
				positive_rate :                                parseFloat(d.positive_rate),
				reproduction_rate :                            parseFloat(d.reproduction_rate),
				new_vaccinations :                             parseFloat(d.new_vaccinations),
				new_vaccinations_per_hundred :                 parseFloat(d.new_vaccinations_per_hundred),
				people_vaccinated :                            parseFloat(d.people_vaccinated),
				people_vaccinated_per_hundred :                parseFloat(d.people_vaccinated_per_hundred),
				people_fully_vaccinated :                      parseFloat(d.people_fully_vaccinated),
				people_fully_vaccinated_per_hundred :          parseFloat(d.people_fully_vaccinated_per_hundred),
				icu_patients :                                 parseFloat(d.icu_patients),
				icu_patients_per_million :                     parseFloat(d.icu_patients_per_million),
				hosp_patients :                                parseFloat(d.hosp_patients),
				hosp_patients_per_million :                    parseFloat(d.hosp_patients_per_million),
				weekly_icu_admissions :                        parseFloat(d.weekly_icu_admissions),
				weekly_icu_admissions_per_million :            parseFloat(d.weekly_icu_admissions_per_million),
				weekly_hosp_admissions :                       parseFloat(d.weekly_hosp_admissions),
				weekly_hosp_admissions_per_million :           parseFloat(d.weekly_hosp_admissions_per_million),
				stringency_index :                             parseFloat(d.stringency_index),
				government_response_index :                    parseFloat(d.government_response_index),
				containment_health_index :                     parseFloat(d.containment_health_index),
				economic_support_index :                       parseFloat(d.economic_support_index),
				c1_school_closing :                            d.c1_school_closing,
				c1_school_closing_numeric :                    parseFloat(d.c1_school_closing_numeric),
				c2_workplace_closing :                         d.c2_workplace_closing,
				c2_workplace_closing_numeric :                 parseFloat(d.c2_workplace_closing_numeric),
				c3_cancel_public_events :                      d.c3_cancel_public_events,
				c3_cancel_public_events_numeric :              parseFloat(d.c3_cancel_public_events_numeric),
				c4_restrictions_on_gatherings :                d.c4_restrictions_on_gatherings,
				c4_restrictions_on_gatherings_numeric :        parseFloat(d.c4_restrictions_on_gatherings_numeric),
				c5_close_public_transport :                    d.c5_close_public_transport,
				c5_close_public_transport_numeric :            parseFloat(d.c5_close_public_transport_numeric),
				c6_stay_at_home_requirements :                 d.c6_stay_at_home_requirements,
				c6_stay_at_home_requirements_numeric :         parseFloat(d.c6_stay_at_home_requirements_numeric),
				c7_restrictions_on_internal_movement :         d.c7_restrictions_on_internal_movement,
				c7_restrictions_on_internal_movement_numeric : parseFloat(d.c7_restrictions_on_internal_movement_numeric),
				c8_international_travel_controls :             d.c8_international_travel_controls,
				c8_international_travel_controls_numeric :     parseFloat(d.c8_international_travel_controls_numeric),
				e1_income_support :                            d.e1_income_support,
				e1_income_support_numeric :                    parseFloat(d.e1_income_support_numeric),
				e2_debt_contract_relief :                      d.e2_debt_contract_relief,
				e2_debt_contract_relief_numeric :              parseFloat(d.e2_debt_contract_relief_numeric),
				e3_fiscal_measures :                           parseFloat(d.e3_fiscal_measures),
				e4_international_support :                     parseFloat(d.e4_international_support),
				h1_public_information_campaigns :              d.h1_public_information_campaigns,
				h1_public_information_campaigns_numeric :      parseFloat(d.h1_public_information_campaigns_numeric),
				h2_testing_policy :                            d.h2_testing_policy,
				h2_testing_policy_numeric :                    parseFloat(d.h2_testing_policy_numeric),
				h3_contact_tracing :                           d.h3_contact_tracing,
				h3_contact_tracing_numeric :                   parseFloat(d.h3_contact_tracing_numeric),
				h6_facial_coverings :                          d.h6_facial_coverings,
				h6_facial_coverings_numeric :                  parseFloat(d.h6_facial_coverings_numeric),
				h7_vaccination_policy :                        d.h7_vaccination_policy,
				h7_vaccination_policy_numeric :                parseFloat(d.h7_vaccination_policy_numeric),
				h4_emergency_investment_in_healthcare :        parseFloat(d.h4_emergency_investment_in_healthcare),
				h5_investment_in_vaccines :                    parseFloat(d.h5_investment_in_vaccines),
				population :                                   parseFloat(d.population),
				population_density :                           parseFloat(d.population_density),
				median_age :                                   parseFloat(d.median_age),
				aged_65_older :                                parseFloat(d.aged_65_older),
				aged_70_older :                                parseFloat(d.aged_70_older),
				gdp_per_capita :                               parseFloat(d.gdp_per_capita),
				extreme_poverty :                              parseFloat(d.extreme_poverty),
				cardiovasc_death_rate :                        parseFloat(d.cardiovasc_death_rate),
				diabetes_prevalence :                          parseFloat(d.diabetes_prevalence),
				female_smokers :                               parseFloat(d.female_smokers),
				male_smokers :                                 parseFloat(d.male_smokers),
				life_expectancy :                              parseFloat(d.life_expectancy),
				human_development_index :                      parseFloat(d.human_development_index)
			};
		}

		function makeViz2() {
			viz2.redrawFunc = redrawViz2;  // need this to be able to handle timestep updates

			// set the dimensions and margins of the graph
			// var margin = {top: 20, right: 20, bottom: 30, left: 50},
			// 	width = 960 - margin.left - margin.right,
			// 	height = 500 - margin.top - margin.bottom;

			viz2.margin = {top: 20, right: 20, bottom: 40, left: 175};

			viz2.dims = {height: 400, width: d3.max([600,  // no smaller than 600px wide
											d3.min([900, // no larger than 900px wide
													Math.floor(window.innerWidth / 2)])])};
			
			viz2.dims["innerHeight"] = viz2.dims.height - viz2.margin.top - viz2.margin.bottom
			viz2.dims["innerWidth"] = viz2.dims.width - viz2.margin.left - viz2.margin.right

			
			/***************
			 *  Create svg
			***************/
			viz2.svg = d3.select("div.viz2")
							.append("svg")
								.attr("width", viz2.dims.width)
								.attr("height", viz2.dims.height)
								.classed("viz2", true)
							.append("g")
                                .attr("transform", "translate(" + viz2.margin.left + "," + viz2.margin.top + ")");
					
			/***************
			 * Scales
			***************/
			viz2.yScale = d3.scaleLinear()
							// rangeRound ensures all pixel values are non-fractional
							.rangeRound([viz2.dims.innerHeight - 10, 0]); // [high, low] so it plots correctly

			let minDate = d3.min(covidData, d => d.date);
			let maxDate = d3.max(covidData, d => d.date);

			viz2.xScale = d3.scaleTime()
							.domain([minDate, maxDate])
							.rangeRound([0, viz2.dims.innerWidth]);			

			/***************
			 * make y-axis (attribute)
			***************/
			viz2.svg.append("g")
				.classed("viz2 y axis", true);

			viz2.yAxis = d3.axisLeft(viz2.yScale);
			
			/***************
			* make x-axis (date)
			***************/
			viz2.xAxis = d3.axisBottom(viz2.xScale);

			viz2.svg.append("g")
				.classed("viz2 x axis", true)
				.attr("transform", "translate(0," + viz2.dims.innerHeight + ")")
				.call(viz2.xAxis);

			/***************
			* x-axis gridlines
			* see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
			***************/
			viz2.xAxisTicks = d3.axisBottom(viz2.xScale)
								.tickSize(-viz2.dims.innerHeight)
								.tickFormat("");

			viz2.svg.append("g")
				.classed("viz2 x grid", true)
				.attr("transform", "translate(0," + viz2.dims.innerHeight + ")")
				.call(viz2.xAxisTicks);  // X-axis gridlines shouldn't change

			//rotate x-axis ticks
			d3.selectAll('.viz2.x.axis .tick text')
				.attr("transform","rotate(-45)")
				.attr("text-anchor","end")

			/***************
			 * y-axis gridlines
			 * see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
			***************/
			viz2.yAxisTicks = d3.axisLeft(viz2.yScale)
								.tickSize(-viz2.dims.innerWidth)
								.tickFormat("");

			viz2.svg.append("g")
				.classed("viz2 y grid", true);
				// note: can't call yAxisTicks yet because it depends on data


			/***************
			 * chart title
			***************/
			viz2.title = viz2.svg.append("text")
				.classed("viz2 title", true)
				.attr("x", 0)
				.attr("y", 0)
				.attr("text-anchor", "start")
				.attr("transform", "translate(0, -10)")
				.style("font-size", "20px");

			viz2SelectedCountries = ["United States", "Australia"]
	}

	function redrawViz2() {
		// // Get the data
		// d3.csv("data2.csv").then(function(data) {

		// // format the data
		// data.forEach(function(d) {
		// d.date = parseTime(d.date);
		// d.close = +d.close;
		// d.open = +d.open;
		// });

		//Get the data for selected countries
		let viz2Data = covidData.filter(d => viz2SelectedCountries.includes(d.countryname));

		let var_metadata = dataDict.filter(d => d.variable_name == attribute)[0];
		
		// if ordinal, use numeric_column attribute (e.g., c1_school_closing_numeric), otherwise use attribute as selected
		let attributeName = var_metadata.display_name;
		let attributeData = var_metadata.data_type == "ordinal" ? var_metadata.numeric_column : attribute;

		viz2.title.text(attributeName + " over time for " + viz2SelectedCountries);
	    // viz2.subtitle.text('viz2SelectedCountries');

		
		/******
		 * update y-axis (attribute)
		******/
		// see if this variable is ordinal; if it does, use its "_numeric" column

		if((var_metadata.data_type == "ordinal")) {
			// get largest value over entire dataset, not just selection
			let maxValue = d3.max(covidData, d => d[attributeData]);

			// set tick values to exactly these values
			// e.g., if maxValue = 2.5, ticks will be: 0, 0.5, 1, 1.5, 2, 2.5
			viz2.yScale.domain([0, maxValue]);
			viz2.yAxis.tickValues(d3.range(0, maxValue + 0.5, 0.5));
		} else {
			// If we're showing an aggregate index like "stringency index", always show 0 to 100.
			// Otherwise, get the maximum value for the attribute *across the whole dataset* for 
			//    the selected countries. This is because we don't want the scales to keep jumping 
			//    around for a given set of countries and making it hard to see changes.
			if(var_metadata.category == 'aggregate indices') {
				maxValue =  100.0;
			} else{
				maxValue = d3.max(covidData.filter(d => viz2SelectedCountries.includes(d.countryname)),
									d => d[attributeData]);
			}
			
			viz2.yScale.domain([0, maxValue]);

			// if we switched from an ordinal variable, get rid of the manually specified ticks
			viz2.yAxis.tickValues(null);
			viz2.yAxisTicks.ticks(5);
		}

		// Update y-axis (x-axis is constant)
		d3.select(".viz2.y.axis")
			.transition()
			.duration(shortenTransitions > 0 ? shortenTransitions : 300)
			.call(viz2.yAxis);

		// add the Y gridlines (x-axis is constant)
		// see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
		d3.select(".viz2.y.grid")
			.call(viz2.yAxisTicks);

		// set all ticks' fonts. These aren't styles/CSS, these are attributes
		d3.selectAll(".viz2.axis")
			.attr("font-size", FONT_SIZES.tick)
			.attr("font-family", "sans-serif");

		/******
		 * Lines of the plot
		******/
		// create a "nested" structure to allow us to draw one line per country
		// see https://stackoverflow.com/a/35279106/1102199
		// "d3.nest()" is deprecated; see https://github.com/d3/d3-array/blob/master/README.md#group
		nestedData = d3.group(viz2Data, d => d.countryname);

		let lineGenerator = d3.line()
								.defined(function(d) {return !isNaN(d[attributeData])})
								.x(d => viz2.xScale(d.date))
								.y(d => viz2.yScale(d[attributeData] >= 0 ? d[attributeData] : 0));

		let lines = viz2.svg.selectAll(".viz2.line")
					.data(nestedData, d => d[0]);  // "key" is the country name in the grouped dataset
					//.data(nestedData);

		lines.exit()
			.transition()
			.duration(shortenTransitions > 0 ? shortenTransitions : 200)
			.style("stroke-opacity", 0)
			.remove();

		lines.enter()
			.append("path")
				.classed("viz2 line", true)
				.attr("stroke-width", 1.5)
				.attr("fill", "none")
				.merge(lines)
					.attr("stroke", d => continentColors(d[1][0].continent)) 
					// .attr("stroke", function (d) {console.log([d, d[1], d[1][0]], continentColors(d[1][0].continent)); return continentColors(d[1][0].continent);})  // d[1] is array of all rows for a country; d[1][0] is the first row of data in that array; we get the continent just from the first row
					.attr("stroke-opacity", 1)
					.attr("id", d => "line-" + d[0])
					.transition()
					.duration(shortenTransitions > 0 ? shortenTransitions : 500)
					.attr("d", d => lineGenerator(d[1]));

		

		/******
		 * Table: fill table by rows
		******/
		// The table generation function
		function tabulate(data, viz2SelectedCountries, attributes, columns) {
			var table = d3.select("body").append("table")
					.attr("style", "margin-left: 250px"),
				thead = table.append("thead"),
				tbody = table.append("tbody");
				lastDate = d3.max(covidData, d => d.date);

			// append the header row
			thead.append("tr")
				.selectAll("th")
				.data(columns)
				.enter()
				.append("th")
					.text(function(column) { return column; });

			// create a row for each object in the data
			var cells = tbody.selectAll("td")
						.data(attributes)
						.enter();
										
			selectAttrCat = d3.select("select#viz2-attrcat");
			
			// // Add row title corresponding to attributes of the category
			// 	Array.from(new Set(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category)))))
			// 		.forEach(function(attributes) {
			// 			selectAttrCat.append('option')
			// 				.attr("value", attributes.variable_name)
			// 				.text(attributes.display_name);
			// 		rows.append("tr")
			// 			.text(attributes.display_name);
			// 		});

			// create a cell in each row for each column 
			// For each row i append Values[i][attribute] where i is the country 
			

			Values = d3.select("select#viz2-values");
			value = Array.from(new Set(covidData.filter(d => ((d.date.getTime()==lastDate.getTime()) 
			&& (viz2SelectedCountries.includes(d.countryname))))))		
			
				
				attributes[0].forEach(function(j){
					// console.log(j.variable_name);
					val = [j.variable_name];
					cells.append("td")
						.text(val);
					
					value.forEach(function(i) {	
						
						val = d3.merge([val, [i[j.variable_name]]]);
						console.log([i[j.variable_name]]);	

					});	
					cells.append("td")
						.text(val);				
					
				});
				
			return table;	

		}


		/******
		 * Table: fill table by columns
		******/
		// The table generation function

		function tabulate(data, viz2SelectedCountries, attributes, columns) {
			var table = d3.select("body").append("table")
					.attr("style", "margin-left: 250px"),
				thead = table.append("thead"),
				tbody = table.append("tbody");
				lastDate = d3.max(covidData, d => d.date);

			// append the header row
			thead.append("tr")
				.selectAll("th")
				.data(columns)
				.enter()
				.append("th")
					.text(function(column) { return column; });
			
			console.log(columns);

			var rows = tbody.selectAll("tr")
						.data(attributes[0])
						.enter()
						.append("tr");
					console.log(rows);
										
			selectAttrCat = d3.select("select#viz2-attrcat");
			
			// get unique categories, then append <option> to <select>
				Array.from(new Set(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category)))))
					.forEach(function(attributes) {
						selectAttrCat.append('option')
							.attr("value", attributes.variable_name)
							.text(attributes.display_name);
					});				
				
			var cells = rows.selectAll("td")

			// For each row i append Values[i][attribute] where i is the country 
			// Values = d3.select("select#viz2-values");
			value = Array.from(new Set(covidData.filter(d => ((d.date.getTime()==lastDate.getTime()) 
			&& (viz2SelectedCountries.includes(d.countryname))))))

			attributes[0].forEach(function(j){

					val = [j.variable_name];

					value.forEach(function(i) {	
						
						val = d3.merge([val, [i[j.variable_name]]]);									
					});	
					
					cells.data(val)
						.enter()
						.append("td")
						.text(function (i) {console.log(i);
							return i; });				
				});

				

			return table;
		}

		/******
		 * Table: fill table with matrix
		******/
		// The table generation function
		function tabulate2(data, viz2SelectedCountries, attributes, columns) {
			var table = d3.select("body").append("table")
					.attr("style", "margin-left: 250px"),
				thead = table.append("thead"),
				tbody = table.append("tbody");
				lastDate = d3.max(covidData, d => d.date);

			// append the header row
			thead.append("tr")
				.selectAll("th")
				.data(columns)
				.enter()
				.append("th")
					.text(function(column) { return column; });
			
			console.log(columns);

			var rows = tbody.selectAll("tr")
						.data(attributes[0])
						.enter()
						.append("tr");
					console.log(rows);
										
			selectAttrCat = d3.select("select#viz2-attrcat");
			
			// get unique categories, then append <option> to <select>
				Array.from(new Set(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category)))))
					.forEach(function(attributes) {
						selectAttrCat.append('option')
							.attr("value", attributes.variable_name)
							.text(attributes.display_name);
					});				
				
			var cells = rows.selectAll("td")

			// For each row i append Values[i][attribute] where i is the country 
			// Values = d3.select("select#viz2-values");
			value = Array.from(new Set(covidData.filter(d => ((d.date.getTime()==lastDate.getTime()) 
			&& (viz2SelectedCountries.includes(d.countryname))))))

			Val = [];
			attributes[0].forEach(function(j){
					val = [j.variable_name];					
					value.forEach(function(i) {					
						val = d3.merge([val, [i[j.variable_name]]]);				
					});	
					Val = d3.merge([Val, [val]]);								
				});
				Val.forEach(function(d, i) {
					// console.log(i);
					console.log(Val[i]);
						// cells.data(Val[i])
				cells.data(function(row) {
					return columns.map(function(column) {
						return {column: column, value: row[column]};
					});
				})
						.enter()
						.append("td")
						.text(function(i) { return i; });
						// .text(function (i) {
						// 	// console.log(i);
						// 	return i; });

						// console.log(cells);
						});
					
				// cells.data(Val)
				// 		.enter()
				// 		.append("td")
				// 		.text(function (i) {console.log(i);
				// 			return i; });
				

			return table;
		}
		/******
		 * Table: backup
		******/
		// The table generation function
		function tabulate(data, viz2SelectedCountries, attributes, columns) {
			var table = d3.select("body").append("table")
					.attr("style", "margin-left: 250px"),
				thead = table.append("thead"),
				tbody = table.append("tbody");
				lastDate = d3.max(covidData, d => d.date);

			// append the header row
			thead.append("tr")
				.selectAll("th")
				.data(columns)
				.enter()
				.append("th")
					.text(function(column) { return column; });
			
			console.log(columns);

			// create a row for each object in the data
			var rows = tbody.selectAll("tr")
						.data(attributes)
						.enter();
										
			selectAttrCat = d3.select("select#viz2-attrcat");
			
			// get unique categories, then append <option> to <select>
				Array.from(new Set(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category)))))
					.forEach(function(attributes) {
						selectAttrCat.append('option')
							.attr("value", attributes.variable_name)
							.text(attributes.display_name);
					rows.append("tr")
						.text(attributes.display_name);
					});

			// create a cell in each row for each column 
			// For each row i append Values[i][attribute] where i is the country 
			Values = d3.select("select#viz2-values");
			value = Array.from(new Set(covidData.filter(d => ((d.date.getTime()==lastDate.getTime()) 
			&& (viz2SelectedCountries.includes(d.countryname))))))
			
			value.forEach(function(i) {	
				// console.log(i.countryname);
				val = [i.countryname];
				attributes[0].forEach(function(j){
				// console.log(i[j.variable_name]);
				val = d3.merge([val, [i[j.variable_name]]]);
				console.log(val);	
				})
				var cells = rows.selectAll("td")
					.data(function(row) {
					return columns.map(function(column) {
						return {column: column, value: row[column]};
					});
				})
				.enter()
				.append("td")
					.text(function(d) { return d.value; });
				
						});
			return table;		

		}

		// render the table
		attributes = [Array.from(new Set(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category)))))];
		columns = d3.merge([[category], viz2SelectedCountries]);
		lastDate = d3.max(covidData, d => d.date);
	
		peopleTable = tabulate2(covidData, viz2SelectedCountries, attributes, columns);
	}



		// load the data and kick things off
		Promise.all([
			d3.csv("data_dictionary.csv", dictRowParser),
            d3.csv("Will_covid_data_subset_1a.csv", dataRowParser),
		]).then(function(files) {
			dataDict = files[0];
			covidData = files[1];

			console.log("Imported all data!");

			/***************************
			* Countries select list. Add countries to select list and set up "change" listener to redraw
			**************************/
			selectCountry = d3.select("select#viz2-countries");

			// get unique countries, then append <option> to <select>
			Array.from(new Set(covidData.map(d => d.countryname)))
				.sort()  // put country names in order in dropdown menu
				.forEach(function(country) {
					selectCountry.append('option')
						.attr("value", country)
						.text(country);
				});
		    

			// create listener
			selectCountry
				.on("change", function() {
					let countries = [];

					selected = d3.select(this)
						.selectAll("option:checked") 
						.each(function() { countries.push(this.value) }); // for each select country, get its value (name)

					// want to maintain ordering of original selection
					viz2SelectedCountries = viz2SelectedCountries.filter(d => countries.includes(d));
					added = countries.filter(d => !viz2SelectedCountries.includes(d));
					viz2SelectedCountries = viz2SelectedCountries.concat(added);

					redrawViz2();
				});

			/***************************
			* 1st dropdown: Category
			**************************/

			//add attributes to the attribute dropdown menu;
			selectCat = d3.select("select#viz2-categories");
			selectAttr = d3.select("select#viz2-attributes");

			
			// get unique categories, then append <option> to <select>
				Array.from(new Set(dataDict.filter(d => d.sort_order != 0)
											.map(d => d.category)))	
					.forEach(function(category) {
						selectCat.append('option')
							.attr("value", category)
							.text(category);
					});

			category = selectCat.select("option:checked").text();  

			// create listener
			selectCat
                    .on("change", function() {
                        category = d3.select(this)
                                        .select("option:checked") 
                                        .text();  

						selectAttr.selectAll("option").remove();

						Array.from(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category))))
							.forEach(function(attribute) {
								selectAttr.append('option')
									.attr("value", attribute.variable_name)
									.text(attribute.display_name);
							});

						attribute = selectAttr.select("option:checked").node().value;  

                        redrawViz2();
                    });


			
			/***************************
			* 2nd dropdown: Attributes
			**************************/		

			// get unique categories, then append <option> to <select>
				Array.from(dataDict.filter(d => ((d.sort_order != 0) && (d.category == category))))
					.forEach(function(attribute) {
						selectAttr.append('option')
							.attr("value", attribute.variable_name)
							.text(attribute.display_name);
					});

				attribute = selectAttr.select("option:checked").node().value;  // want value (variable_name), not the text (display_name)

                // create listener
                selectAttr
                    .on("change", function() {
                        attribute = d3.select(this)
                                        .select("option:checked") 
                                        .node().value;  // want value (variable_name), not the text (display_name)
                        redrawViz2();
                    });
                
			
			/***************************
			* Create the viz!
			**************************/
			makeViz2();
			redrawViz2();
			d3.selectAll(".spinner").remove();

		})
		// .catch(function(err) {
		// 	d3.selectAll(".spinner").remove();
		// 	console.error('Error: ' + err);
		// })
						
		</script>
	</body>
</html>



