<!DOCTYPE html>
<html lang="en">
<head>
    <!DOCTYPE html>
    <meta charset="utf-8">
    <link rel="icon" href="data:;base64,=">
    <title>Viz 2</title>
    <script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
    <link rel="stylesheet" href="covid.css">
</head>
<style>
    .attribute-name {font-weight: bold;}
    .viz2 table, th, td {
        border: 1px solid black;
        border-collapse: collapse;
    }
</style>
<body>
    <div class="spinner"></div>
    <label for="viz2-categories">Category: </label><select name="viz2-categories" id="viz2-categories"></select>
    <br><br>

    <label for="viz2-attributes">Attribute: </label><select name="viz2-attributes" id="viz2-attributes"></select>
    <br><br>

    <label for="viz2-countries">Countries: </label><select name="viz2-countries" id="viz2-countries" multiple></select>
    <br><br>

    <div class="viz2"></div>

    <script type="text/javascript">
    /**
     * TODO:
     * - round values
     * - update styling of table
     * - add table title
     
     */

    const FONT_SIZES = {
        tick: 12,
        axisTitle: 14,
        title: 16
    }

    // color scale is here: https://github.com/d3/d3-scale-chromatic#schemeTableau10
    const continentColors = d3.scaleOrdinal(d3.schemeTableau10)
                                .domain(["Africa", "Asia", "Europe", "North America", "Oceania", "South America"]);

    var viz2 = {};
    var parseDate = d3.timeParse("%Y-%m-%d");  // for converting strings to dates ("2020-03-31", for example)

    var covidData;
    var dataDict;
    var viz2SelectedCountries = [];
    var viz2Category;
    var viz2Attribute;
    var shortenTransitions = 0;
    var updateTable = false;  // this is so that, when the attribute selector changes, we don't update the table too

    function dictRowParser(d) {
        return {
            variable_name :  d.variable_name,  // name of attribute in CSV
            data_type :      d.data_type,  // string, date, numeric, or ordinal
            display_name :   d.display_name,  // pretty name of variable, for dropdowns, titles, etc.
            sort_order :     parseInt(d.sort_order),  // when showing in dropdown menus, sort in this order
            category :       d.category,   // when grouping variables (e.g., in a summary table, these are the groupings)
            numeric_column : d.numeric_column  // for ordinal columns, e.g., c1_school_closing, there is a corresponding "numeric" column
        };
    }

    function dataRowParser(d) {
        return {
            countryname :                                  d.countryname,
            date :                                         parseDate(d.date),
            continent :                                    d.continent,
            new_cases :                                    parseFloat(d.new_cases),
            new_cases_per_million :                        parseFloat(d.new_cases_per_million),
            total_cases :                                  parseFloat(d.total_cases),
            total_cases_per_million :                      parseFloat(d.total_cases_per_million),
            new_deaths :                                   parseFloat(d.new_deaths),
            new_deaths_per_million :                       parseFloat(d.new_deaths_per_million),
            total_deaths :                                 parseFloat(d.total_deaths),
            total_deaths_per_million :                     parseFloat(d.total_deaths_per_million),
            new_tests :                                    parseFloat(d.new_tests),
            new_tests_per_thousand :                       parseFloat(d.new_tests_per_thousand),
            total_tests :                                  parseFloat(d.total_tests),
            total_tests_per_thousand :                     parseFloat(d.total_tests_per_thousand),
            positive_rate :                                parseFloat(d.positive_rate),
            reproduction_rate :                            parseFloat(d.reproduction_rate),
            new_vaccinations :                             parseFloat(d.new_vaccinations),
            new_vaccinations_per_hundred :                 parseFloat(d.new_vaccinations_per_hundred),
            people_vaccinated :                            parseFloat(d.people_vaccinated),
            people_vaccinated_per_hundred :                parseFloat(d.people_vaccinated_per_hundred),
            people_fully_vaccinated :                      parseFloat(d.people_fully_vaccinated),
            people_fully_vaccinated_per_hundred :          parseFloat(d.people_fully_vaccinated_per_hundred),
            icu_patients :                                 parseFloat(d.icu_patients),
            icu_patients_per_million :                     parseFloat(d.icu_patients_per_million),
            hosp_patients :                                parseFloat(d.hosp_patients),
            hosp_patients_per_million :                    parseFloat(d.hosp_patients_per_million),
            weekly_icu_admissions :                        parseFloat(d.weekly_icu_admissions),
            weekly_icu_admissions_per_million :            parseFloat(d.weekly_icu_admissions_per_million),
            weekly_hosp_admissions :                       parseFloat(d.weekly_hosp_admissions),
            weekly_hosp_admissions_per_million :           parseFloat(d.weekly_hosp_admissions_per_million),
            stringency_index :                             parseFloat(d.stringency_index),
            government_response_index :                    parseFloat(d.government_response_index),
            containment_health_index :                     parseFloat(d.containment_health_index),
            economic_support_index :                       parseFloat(d.economic_support_index),
            c1_school_closing :                            d.c1_school_closing,
            c1_school_closing_numeric :                    parseFloat(d.c1_school_closing_numeric),
            c2_workplace_closing :                         d.c2_workplace_closing,
            c2_workplace_closing_numeric :                 parseFloat(d.c2_workplace_closing_numeric),
            c3_cancel_public_events :                      d.c3_cancel_public_events,
            c3_cancel_public_events_numeric :              parseFloat(d.c3_cancel_public_events_numeric),
            c4_restrictions_on_gatherings :                d.c4_restrictions_on_gatherings,
            c4_restrictions_on_gatherings_numeric :        parseFloat(d.c4_restrictions_on_gatherings_numeric),
            c5_close_public_transport :                    d.c5_close_public_transport,
            c5_close_public_transport_numeric :            parseFloat(d.c5_close_public_transport_numeric),
            c6_stay_at_home_requirements :                 d.c6_stay_at_home_requirements,
            c6_stay_at_home_requirements_numeric :         parseFloat(d.c6_stay_at_home_requirements_numeric),
            c7_restrictions_on_internal_movement :         d.c7_restrictions_on_internal_movement,
            c7_restrictions_on_internal_movement_numeric : parseFloat(d.c7_restrictions_on_internal_movement_numeric),
            c8_international_travel_controls :             d.c8_international_travel_controls,
            c8_international_travel_controls_numeric :     parseFloat(d.c8_international_travel_controls_numeric),
            e1_income_support :                            d.e1_income_support,
            e1_income_support_numeric :                    parseFloat(d.e1_income_support_numeric),
            e2_debt_contract_relief :                      d.e2_debt_contract_relief,
            e2_debt_contract_relief_numeric :              parseFloat(d.e2_debt_contract_relief_numeric),
            e3_fiscal_measures :                           parseFloat(d.e3_fiscal_measures),
            e4_international_support :                     parseFloat(d.e4_international_support),
            h1_public_information_campaigns :              d.h1_public_information_campaigns,
            h1_public_information_campaigns_numeric :      parseFloat(d.h1_public_information_campaigns_numeric),
            h2_testing_policy :                            d.h2_testing_policy,
            h2_testing_policy_numeric :                    parseFloat(d.h2_testing_policy_numeric),
            h3_contact_tracing :                           d.h3_contact_tracing,
            h3_contact_tracing_numeric :                   parseFloat(d.h3_contact_tracing_numeric),
            h6_facial_coverings :                          d.h6_facial_coverings,
            h6_facial_coverings_numeric :                  parseFloat(d.h6_facial_coverings_numeric),
            h7_vaccination_policy :                        d.h7_vaccination_policy,
            h7_vaccination_policy_numeric :                parseFloat(d.h7_vaccination_policy_numeric),
            h4_emergency_investment_in_healthcare :        parseFloat(d.h4_emergency_investment_in_healthcare),
            h5_investment_in_vaccines :                    parseFloat(d.h5_investment_in_vaccines),
            population :                                   parseFloat(d.population),
            population_density :                           parseFloat(d.population_density),
            median_age :                                   parseFloat(d.median_age),
            aged_65_older :                                parseFloat(d.aged_65_older),
            aged_70_older :                                parseFloat(d.aged_70_older),
            gdp_per_capita :                               parseFloat(d.gdp_per_capita),
            extreme_poverty :                              parseFloat(d.extreme_poverty),
            cardiovasc_death_rate :                        parseFloat(d.cardiovasc_death_rate),
            diabetes_prevalence :                          parseFloat(d.diabetes_prevalence),
            female_smokers :                               parseFloat(d.female_smokers),
            male_smokers :                                 parseFloat(d.male_smokers),
            life_expectancy :                              parseFloat(d.life_expectancy),
            human_development_index :                      parseFloat(d.human_development_index),
            iso_code :                                      d.iso_code
        };
    }

    function redrawViz2() {
        //Get the data for selected countries
        let viz2Data = covidData.filter(d => viz2SelectedCountries.includes(d.countryname));
        let var_metadata = dataDict.filter(d => d.variable_name == viz2Attribute)[0];

        // if ordinal, use numeric_column attribute (e.g., c1_school_closing_numeric), otherwise use attribute as selected
        let attributeName = var_metadata.display_name;
        let attributeData = var_metadata.data_type == "ordinal" ? var_metadata.numeric_column : viz2Attribute;

        viz2.title.text(attributeName + " over time for " + viz2SelectedCountries);
        // viz2.subtitle.text('viz2SelectedCountries');

        /******
         * update y-axis (attribute)
        ******/
        // see if this variable is ordinal; if it is, use its "_numeric" column

        if((var_metadata.data_type == "ordinal")) {
            // get largest value over entire dataset, not just selection
            let maxValue = d3.max(covidData, d => d[attributeData]);

            // set tick values to exactly these values
            // e.g., if maxValue = 2.5, ticks will be: 0, 0.5, 1, 1.5, 2, 2.5
            viz2.yScale.domain([0, maxValue]);
            viz2.yAxis.tickValues(d3.range(0, maxValue + 0.5, 0.5));
        } else {
            // If we're showing an aggregate index like "stringency index", always show 0 to 100.
            // Otherwise, get the maximum value for the attribute *across the whole dataset* for
            //    the selected countries. This is because we don't want the scales to keep jumping
            //    around for a given set of countries and making it hard to see changes.
            if(var_metadata.category == 'aggregate indices') {
                maxValue =  100.0;
            } else{
                maxValue = d3.max(covidData.filter(d => viz2SelectedCountries.includes(d.countryname)),
                                    d => d[attributeData]);
            }

            viz2.yScale.domain([0, maxValue]);

            // if we switched from an ordinal variable, get rid of the manually specified ticks
            viz2.yAxis.tickValues(null);
            viz2.yAxisTicks.ticks(5);
        }

        // Update y-axis (x-axis is constant)
        d3.select(".viz2.y.axis")
            .transition()
            .duration(shortenTransitions > 0 ? shortenTransitions : 300)
            .call(viz2.yAxis);

        // add the Y gridlines (x-axis is constant)
        // see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
        d3.select(".viz2.y.grid")
            .call(viz2.yAxisTicks);

        // set all ticks' fonts. These aren't styles/CSS, these are attributes
        d3.selectAll(".viz2.axis")
            .attr("font-size", FONT_SIZES.tick)
            .attr("font-family", "sans-serif");

        /******
         * Lines of the plot
        ******/
        // create a "nested" structure to allow us to draw one line per country
        // see https://stackoverflow.com/a/35279106/1102199
        // "d3.nest()" is deprecated; see https://github.com/d3/d3-array/blob/master/README.md#group
        nestedData = d3.group(viz2Data, d => d.countryname);

        let lineGenerator = d3.line()
                                .defined(function(d) {return !isNaN(d[attributeData])})
                                .x(d => viz2.xScale(d.date))
                                .y(d => viz2.yScale(d[attributeData] >= 0 ? d[attributeData] : 0));

        let lines = viz2.svg.selectAll(".viz2.line")
                    .data(nestedData, d => d[0]);  // "key" is the country name in the grouped dataset
                    //.data(nestedData);

        lines.exit()
            .transition()
            .duration(shortenTransitions > 0 ? shortenTransitions : 200)
            .style("stroke-opacity", 0)
            .remove();

        lines.enter()
            .append("path")
                .classed("viz2 line", true)
                .attr("stroke-width", 1.5)
                .attr("fill", "none")
                .merge(lines)
                    .attr("stroke", d => continentColors(d[1][0].continent))
                    // .attr("stroke", function (d) {console.log([d, d[1], d[1][0]], continentColors(d[1][0].continent)); return continentColors(d[1][0].continent);})  // d[1] is array of all rows for a country; d[1][0] is the first row of data in that array; we get the continent just from the first row
                    .attr("stroke-opacity", 1)
                    .attr("id", d => "line-" + d[0])
                    .transition()
                    .duration(shortenTransitions > 0 ? shortenTransitions : 500)
                    .attr("d", d => lineGenerator(d[1]));

        /************
         * Create the table
        ************/
        if((!updateTable) || (viz2Data.length == 0)) {return}  // no need to update table if we didn't change our category

        updateTable = false;  // reset for next time

        const categoryAttributes = dataDict.filter(d => d.category == viz2Category);
        const maxDate = d3.max(covidData, d => d.date).getTime();
        const viz2TableData = viz2Data.filter(d => d.date.getTime() == maxDate);  // table only shows latest data
        
        d3.select(".viz2 table").remove(); // remove the table we're updating
        const table = d3.select(".viz2").append("table");

        // append the header row. First column = "attribute", then one column per country
        const headerRow = table.append("thead").append("tr");
        headerRow.append("th").text("Attribute");

        viz2SelectedCountries.forEach(function(country) {
            headerRow.append("th").text(country);
        });

        // add the data rows. First cell in each row is the attribute, the remaining cells are the countries' values
        const tbody = table.append("tbody");

        categoryAttributes.forEach(function(attribute) {
            const tr = tbody.append("tr");

            tr.append("td")
                .classed("attribute-name", true)
                .text(attribute.display_name);
            
            // make a map from country --> attribute value
            const attributeMap = viz2TableData.reduce(function(map, obj) {map[obj.countryname] = obj[attribute.variable_name]; return map}, {});

            // add each country's value, in order of appearance
            viz2SelectedCountries.forEach(function(country) {
                tr.append("td").text(attributeMap[country]);
            });
        });
    }

    function makeViz2() {
        viz2.margin = {top: 20, right: 20, bottom: 40, left: 175};

        viz2.dims = {height: 400, width: d3.max([600,  // no smaller than 600px wide
                                        d3.min([900, // no larger than 900px wide
                                                Math.floor(window.innerWidth / 2)])])};

        viz2.dims["innerHeight"] = viz2.dims.height - viz2.margin.top - viz2.margin.bottom
        viz2.dims["innerWidth"] = viz2.dims.width - viz2.margin.left - viz2.margin.right


        /***************
         *  Create svg
        ***************/
        viz2.svg = d3.select("div.viz2")
                        .append("svg")
                            .attr("width", viz2.dims.width)
                            .attr("height", viz2.dims.height)
                            .classed("viz2", true)
                        .append("g")
                            .attr("transform", "translate(" + viz2.margin.left + "," + viz2.margin.top + ")");

        /***************
         * Scales
        ***************/
        viz2.yScale = d3.scaleLinear()
                        // rangeRound ensures all pixel values are non-fractional
                        .rangeRound([viz2.dims.innerHeight - 10, 0]); // [high, low] so it plots correctly

        let minDate = d3.min(covidData, d => d.date);
        let maxDate = d3.max(covidData, d => d.date);

        viz2.xScale = d3.scaleTime()
                        .domain([minDate, maxDate])
                        .rangeRound([0, viz2.dims.innerWidth]);

        /***************
         * make y-axis (attribute)
        ***************/
        viz2.svg.append("g")
            .classed("viz2 y axis", true);

        viz2.yAxis = d3.axisLeft(viz2.yScale);

        /***************
        * make x-axis (date)
        ***************/
        viz2.xAxis = d3.axisBottom(viz2.xScale);

        viz2.svg.append("g")
            .classed("viz2 x axis", true)
            .attr("transform", "translate(0," + viz2.dims.innerHeight + ")")
            .call(viz2.xAxis);

        /***************
        * x-axis gridlines
        * see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
        ***************/
        viz2.xAxisTicks = d3.axisBottom(viz2.xScale)
                            .tickSize(-viz2.dims.innerHeight)
                            .tickFormat("");

        viz2.svg.append("g")
            .classed("viz2 x grid", true)
            .attr("transform", "translate(0," + viz2.dims.innerHeight + ")")
            .call(viz2.xAxisTicks);  // X-axis gridlines shouldn't change

        //rotate x-axis ticks
        d3.selectAll('.viz2.x.axis .tick text')
            .attr("transform","rotate(-45)")
            .attr("text-anchor","end")

        /***************
         * y-axis gridlines
         * see: https://bl.ocks.org/d3noob/c506ac45617cf9ed39337f99f8511218
        ***************/
        viz2.yAxisTicks = d3.axisLeft(viz2.yScale)
                            .tickSize(-viz2.dims.innerWidth)
                            .tickFormat("");

        viz2.svg.append("g")
            .classed("viz2 y grid", true);
            // note: can't call yAxisTicks yet because it depends on data


        /***************
         * chart title
        ***************/
        viz2.title = viz2.svg.append("text")
            .classed("viz2 title", true)
            .attr("x", 0)
            .attr("y", 0)
            .attr("text-anchor", "start")
            .attr("transform", "translate(0, -10)")
            .style("font-size", "20px");
    }




    // load the data and kick things off
    Promise.all([
        d3.csv("../data/data_dictionary.csv", dictRowParser),
        d3.csv("../data/covid_data.csv", dataRowParser),
    ]).then(function(files) {
        dataDict = files[0];
        covidData = files[1];

        console.log("Imported all data!");

        /***************************
        * Countries select list. Add countries to select list and set up "change" listener to redraw
        **************************/
        selectCountry = d3.select("select#viz2-countries");

        // get unique countries, then append <option> to <select>
        Array.from(new Set(covidData.map(d => d.countryname)))
            .sort()  // put country names in order in dropdown menu
            .forEach(function(country) {
                selectCountry.append('option')
                    .attr("value", country)
                    .text(country);
            });

        // create listener
        selectCountry
            .on("change", function() {
                let countries = [];

                selected = d3.select(this)
                    .selectAll("option:checked")
                    .each(function() { countries.push(this.value) }); // for each select country, get its value (name)

                // want to maintain ordering of original selection
                viz2SelectedCountries = viz2SelectedCountries.filter(d => countries.includes(d));
                added = countries.filter(d => !viz2SelectedCountries.includes(d));
                viz2SelectedCountries = viz2SelectedCountries.concat(added);
                updateTable = true;

                redrawViz2();
            });

        /***************************
        * 1st dropdown: Category
        **************************/
        //add attributes to the attribute dropdown menu;
        selectCat = d3.select("select#viz2-categories");
        selectAttr = d3.select("select#viz2-attributes");

        // get unique categories, then append <option> to <select>
        Array.from(new Set(dataDict.filter(d => d.sort_order != 0)
                                    .map(d => d.category)))
            .forEach(function(category) {
                selectCat.append('option')
                    .attr("value", category)
                    .text(category);
            });

        viz2Category = selectCat.select("option:checked").text();
        updateTable = true;

        function populateAttributeSelector(category) {
            selectAttr.selectAll("option").remove();

            dataDict.filter(d => d.category == category)
                .forEach(function(attribute) {
                    selectAttr.append('option')
                        .attr("value", attribute.variable_name)
                        .text(attribute.display_name);
                });
        }

        // create listener
        selectCat.on("change", function() {
            viz2Category = d3.select(this)
                        .select("option:checked")
                        .text();
            updateTable = true;

            // use the new category's category to populate the attribute select list
            populateAttributeSelector(viz2Category);
            viz2Attribute = selectAttr.select("option:checked").attr("value");

            redrawViz2();
        });

        /***************************
        * 2nd dropdown: Attributes
        **************************/
        populateAttributeSelector(viz2Category);
        viz2Attribute = selectAttr.select("option:checked").attr("value");

        // create listener
        selectAttr
            .on("change", function() {
                viz2Attribute = d3.select(this)
                                .select("option:checked")
                                .attr("value");  // want value (variable_name), not the text (display_name)
                redrawViz2();
            });


        /***************************
        * Create the viz!
        **************************/
        makeViz2();
        redrawViz2();
        d3.selectAll(".spinner").remove();

    })
    // .catch(function(err) {
    //     d3.selectAll(".spinner").remove();
    //     console.error('Error: ' + err);
    // })

    </script>
</body>
</html>



